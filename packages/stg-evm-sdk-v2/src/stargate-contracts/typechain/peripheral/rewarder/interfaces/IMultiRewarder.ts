/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
    BaseContract,
    BigNumber,
    BigNumberish,
    BytesLike,
    CallOverrides,
    ContractTransaction,
    Overrides,
    PayableOverrides,
    PopulatedTransaction,
    Signer,
    utils,
} from 'ethers'
import type { FunctionFragment, Result, EventFragment } from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from '../../../common'

export declare namespace IMultiRewarder {
    export type RewardDetailsStruct = {
        rewardPerSec: PromiseOrValue<BigNumberish>
        totalAllocPoints: PromiseOrValue<BigNumberish>
        start: PromiseOrValue<BigNumberish>
        end: PromiseOrValue<BigNumberish>
        exists: PromiseOrValue<boolean>
    }

    export type RewardDetailsStructOutput = [BigNumber, BigNumber, number, number, boolean] & {
        rewardPerSec: BigNumber
        totalAllocPoints: BigNumber
        start: number
        end: number
        exists: boolean
    }
}

export interface IMultiRewarderInterface extends utils.Interface {
    functions: {
        'allocPointsByReward(address)': FunctionFragment
        'allocPointsByStake(address)': FunctionFragment
        'connect(address)': FunctionFragment
        'extendReward(address,uint256)': FunctionFragment
        'getRewards(address,address)': FunctionFragment
        'onUpdate(address,address,uint256,uint256,uint256)': FunctionFragment
        'rewardDetails(address)': FunctionFragment
        'rewardTokens()': FunctionFragment
        'setAllocPoints(address,address[],uint48[])': FunctionFragment
        'setReward(address,uint256,uint48,uint48)': FunctionFragment
        'stopReward(address,address,bool)': FunctionFragment
    }

    getFunction(
        nameOrSignatureOrTopic:
            | 'allocPointsByReward'
            | 'allocPointsByStake'
            | 'connect'
            | 'extendReward'
            | 'getRewards'
            | 'onUpdate'
            | 'rewardDetails'
            | 'rewardTokens'
            | 'setAllocPoints'
            | 'setReward'
            | 'stopReward'
    ): FunctionFragment

    encodeFunctionData(functionFragment: 'allocPointsByReward', values: [PromiseOrValue<string>]): string
    encodeFunctionData(functionFragment: 'allocPointsByStake', values: [PromiseOrValue<string>]): string
    encodeFunctionData(functionFragment: 'connect', values: [PromiseOrValue<string>]): string
    encodeFunctionData(
        functionFragment: 'extendReward',
        values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
    ): string
    encodeFunctionData(functionFragment: 'getRewards', values: [PromiseOrValue<string>, PromiseOrValue<string>]): string
    encodeFunctionData(
        functionFragment: 'onUpdate',
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
        ]
    ): string
    encodeFunctionData(functionFragment: 'rewardDetails', values: [PromiseOrValue<string>]): string
    encodeFunctionData(functionFragment: 'rewardTokens', values?: undefined): string
    encodeFunctionData(
        functionFragment: 'setAllocPoints',
        values: [PromiseOrValue<string>, PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
    ): string
    encodeFunctionData(
        functionFragment: 'setReward',
        values: [
            PromiseOrValue<string>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
            PromiseOrValue<BigNumberish>,
        ]
    ): string
    encodeFunctionData(
        functionFragment: 'stopReward',
        values: [PromiseOrValue<string>, PromiseOrValue<string>, PromiseOrValue<boolean>]
    ): string

    decodeFunctionResult(functionFragment: 'allocPointsByReward', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'allocPointsByStake', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'connect', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'extendReward', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'getRewards', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'onUpdate', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'rewardDetails', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'rewardTokens', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'setAllocPoints', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'setReward', data: BytesLike): Result
    decodeFunctionResult(functionFragment: 'stopReward', data: BytesLike): Result

    events: {
        'AllocPointsSet(address,address[],uint48[])': EventFragment
        'PoolRegistered(address,address)': EventFragment
        'RewardExtended(address,uint256,uint48)': EventFragment
        'RewardRegistered(address)': EventFragment
        'RewardSet(address,uint256,uint256,uint48,uint48)': EventFragment
        'RewardStopped(address,address,bool)': EventFragment
        'RewarderConnected(address)': EventFragment
        'RewardsClaimed(address,address[],uint256[])': EventFragment
    }

    getEvent(nameOrSignatureOrTopic: 'AllocPointsSet'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'PoolRegistered'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewardExtended'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewardRegistered'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewardSet'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewardStopped'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewarderConnected'): EventFragment
    getEvent(nameOrSignatureOrTopic: 'RewardsClaimed'): EventFragment
}

export interface AllocPointsSetEventObject {
    rewardToken: string
    stakeToken: string[]
    allocPoint: number[]
}
export type AllocPointsSetEvent = TypedEvent<[string, string[], number[]], AllocPointsSetEventObject>

export type AllocPointsSetEventFilter = TypedEventFilter<AllocPointsSetEvent>

export interface PoolRegisteredEventObject {
    rewardToken: string
    stakeToken: string
}
export type PoolRegisteredEvent = TypedEvent<[string, string], PoolRegisteredEventObject>

export type PoolRegisteredEventFilter = TypedEventFilter<PoolRegisteredEvent>

export interface RewardExtendedEventObject {
    rewardToken: string
    amountAdded: BigNumber
    newEnd: number
}
export type RewardExtendedEvent = TypedEvent<[string, BigNumber, number], RewardExtendedEventObject>

export type RewardExtendedEventFilter = TypedEventFilter<RewardExtendedEvent>

export interface RewardRegisteredEventObject {
    rewardToken: string
}
export type RewardRegisteredEvent = TypedEvent<[string], RewardRegisteredEventObject>

export type RewardRegisteredEventFilter = TypedEventFilter<RewardRegisteredEvent>

export interface RewardSetEventObject {
    rewardToken: string
    amountAdded: BigNumber
    amountPeriod: BigNumber
    start: number
    duration: number
}
export type RewardSetEvent = TypedEvent<[string, BigNumber, BigNumber, number, number], RewardSetEventObject>

export type RewardSetEventFilter = TypedEventFilter<RewardSetEvent>

export interface RewardStoppedEventObject {
    rewardToken: string
    receiver: string
    pullTokens: boolean
}
export type RewardStoppedEvent = TypedEvent<[string, string, boolean], RewardStoppedEventObject>

export type RewardStoppedEventFilter = TypedEventFilter<RewardStoppedEvent>

export interface RewarderConnectedEventObject {
    stakingToken: string
}
export type RewarderConnectedEvent = TypedEvent<[string], RewarderConnectedEventObject>

export type RewarderConnectedEventFilter = TypedEventFilter<RewarderConnectedEvent>

export interface RewardsClaimedEventObject {
    user: string
    rewardTokens: string[]
    amounts: BigNumber[]
}
export type RewardsClaimedEvent = TypedEvent<[string, string[], BigNumber[]], RewardsClaimedEventObject>

export type RewardsClaimedEventFilter = TypedEventFilter<RewardsClaimedEvent>

export interface IMultiRewarder extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this
    attach(addressOrName: string): this
    deployed(): Promise<this>

    interface: IMultiRewarderInterface

    queryFilter<TEvent extends TypedEvent>(
        event: TypedEventFilter<TEvent>,
        fromBlockOrBlockhash?: string | number | undefined,
        toBlock?: string | number | undefined
    ): Promise<Array<TEvent>>

    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>
    listeners(eventName?: string): Array<Listener>
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this
    removeAllListeners(eventName?: string): this
    off: OnEvent<this>
    on: OnEvent<this>
    once: OnEvent<this>
    removeListener: OnEvent<this>

    functions: {
        allocPointsByReward(
            rewardToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], number[]] & { stakingTokens: string[]; allocPoints: number[] }>

        allocPointsByStake(
            stakingToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], number[]] & { rewardTokens: string[]; allocPoints: number[] }>

        connect(
            stakingToken: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>

        extendReward(
            rewardToken: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>

        getRewards(
            stakingToken: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], BigNumber[]]>

        onUpdate(
            token: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            oldStake: PromiseOrValue<BigNumberish>,
            oldSupply: PromiseOrValue<BigNumberish>,
            newStake: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>

        rewardDetails(
            rewardToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[IMultiRewarder.RewardDetailsStructOutput]>

        rewardTokens(overrides?: CallOverrides): Promise<[string[]]>

        setAllocPoints(
            rewardToken: PromiseOrValue<string>,
            stakingTokens: PromiseOrValue<string>[],
            allocPoints: PromiseOrValue<BigNumberish>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>

        setReward(
            rewardToken: PromiseOrValue<string>,
            rewards: PromiseOrValue<BigNumberish>,
            start: PromiseOrValue<BigNumberish>,
            duration: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>

        stopReward(
            rewardToken: PromiseOrValue<string>,
            receiver: PromiseOrValue<string>,
            pullTokens: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<ContractTransaction>
    }

    allocPointsByReward(
        rewardToken: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<[string[], number[]] & { stakingTokens: string[]; allocPoints: number[] }>

    allocPointsByStake(
        stakingToken: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<[string[], number[]] & { rewardTokens: string[]; allocPoints: number[] }>

    extendReward(
        rewardToken: PromiseOrValue<string>,
        amount: PromiseOrValue<BigNumberish>,
        overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    getRewards(
        stakingToken: PromiseOrValue<string>,
        user: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<[string[], BigNumber[]]>

    onUpdate(
        token: PromiseOrValue<string>,
        user: PromiseOrValue<string>,
        oldStake: PromiseOrValue<BigNumberish>,
        oldSupply: PromiseOrValue<BigNumberish>,
        newStake: PromiseOrValue<BigNumberish>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    rewardDetails(
        rewardToken: PromiseOrValue<string>,
        overrides?: CallOverrides
    ): Promise<IMultiRewarder.RewardDetailsStructOutput>

    rewardTokens(overrides?: CallOverrides): Promise<string[]>

    setAllocPoints(
        rewardToken: PromiseOrValue<string>,
        stakingTokens: PromiseOrValue<string>[],
        allocPoints: PromiseOrValue<BigNumberish>[],
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    setReward(
        rewardToken: PromiseOrValue<string>,
        rewards: PromiseOrValue<BigNumberish>,
        start: PromiseOrValue<BigNumberish>,
        duration: PromiseOrValue<BigNumberish>,
        overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    stopReward(
        rewardToken: PromiseOrValue<string>,
        receiver: PromiseOrValue<string>,
        pullTokens: PromiseOrValue<boolean>,
        overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    callStatic: {
        allocPointsByReward(
            rewardToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], number[]] & { stakingTokens: string[]; allocPoints: number[] }>

        allocPointsByStake(
            stakingToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], number[]] & { rewardTokens: string[]; allocPoints: number[] }>

        connect(stakingToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>

        extendReward(
            rewardToken: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>

        getRewards(
            stakingToken: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<[string[], BigNumber[]]>

        onUpdate(
            token: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            oldStake: PromiseOrValue<BigNumberish>,
            oldSupply: PromiseOrValue<BigNumberish>,
            newStake: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>

        rewardDetails(
            rewardToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<IMultiRewarder.RewardDetailsStructOutput>

        rewardTokens(overrides?: CallOverrides): Promise<string[]>

        setAllocPoints(
            rewardToken: PromiseOrValue<string>,
            stakingTokens: PromiseOrValue<string>[],
            allocPoints: PromiseOrValue<BigNumberish>[],
            overrides?: CallOverrides
        ): Promise<void>

        setReward(
            rewardToken: PromiseOrValue<string>,
            rewards: PromiseOrValue<BigNumberish>,
            start: PromiseOrValue<BigNumberish>,
            duration: PromiseOrValue<BigNumberish>,
            overrides?: CallOverrides
        ): Promise<void>

        stopReward(
            rewardToken: PromiseOrValue<string>,
            receiver: PromiseOrValue<string>,
            pullTokens: PromiseOrValue<boolean>,
            overrides?: CallOverrides
        ): Promise<void>
    }

    filters: {
        'AllocPointsSet(address,address[],uint48[])'(
            rewardToken?: PromiseOrValue<string> | null,
            stakeToken?: PromiseOrValue<string>[] | null,
            allocPoint?: null
        ): AllocPointsSetEventFilter
        AllocPointsSet(
            rewardToken?: PromiseOrValue<string> | null,
            stakeToken?: PromiseOrValue<string>[] | null,
            allocPoint?: null
        ): AllocPointsSetEventFilter

        'PoolRegistered(address,address)'(
            rewardToken?: PromiseOrValue<string> | null,
            stakeToken?: PromiseOrValue<string> | null
        ): PoolRegisteredEventFilter
        PoolRegistered(
            rewardToken?: PromiseOrValue<string> | null,
            stakeToken?: PromiseOrValue<string> | null
        ): PoolRegisteredEventFilter

        'RewardExtended(address,uint256,uint48)'(
            rewardToken?: PromiseOrValue<string> | null,
            amountAdded?: null,
            newEnd?: null
        ): RewardExtendedEventFilter
        RewardExtended(
            rewardToken?: PromiseOrValue<string> | null,
            amountAdded?: null,
            newEnd?: null
        ): RewardExtendedEventFilter

        'RewardRegistered(address)'(rewardToken?: PromiseOrValue<string> | null): RewardRegisteredEventFilter
        RewardRegistered(rewardToken?: PromiseOrValue<string> | null): RewardRegisteredEventFilter

        'RewardSet(address,uint256,uint256,uint48,uint48)'(
            rewardToken?: PromiseOrValue<string> | null,
            amountAdded?: null,
            amountPeriod?: null,
            start?: null,
            duration?: null
        ): RewardSetEventFilter
        RewardSet(
            rewardToken?: PromiseOrValue<string> | null,
            amountAdded?: null,
            amountPeriod?: null,
            start?: null,
            duration?: null
        ): RewardSetEventFilter

        'RewardStopped(address,address,bool)'(
            rewardToken?: PromiseOrValue<string> | null,
            receiver?: PromiseOrValue<string> | null,
            pullTokens?: null
        ): RewardStoppedEventFilter
        RewardStopped(
            rewardToken?: PromiseOrValue<string> | null,
            receiver?: PromiseOrValue<string> | null,
            pullTokens?: null
        ): RewardStoppedEventFilter

        'RewarderConnected(address)'(stakingToken?: PromiseOrValue<string> | null): RewarderConnectedEventFilter
        RewarderConnected(stakingToken?: PromiseOrValue<string> | null): RewarderConnectedEventFilter

        'RewardsClaimed(address,address[],uint256[])'(
            user?: PromiseOrValue<string> | null,
            rewardTokens?: null,
            amounts?: null
        ): RewardsClaimedEventFilter
        RewardsClaimed(
            user?: PromiseOrValue<string> | null,
            rewardTokens?: null,
            amounts?: null
        ): RewardsClaimedEventFilter
    }

    estimateGas: {
        allocPointsByReward(rewardToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

        allocPointsByStake(stakingToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

        connect(
            stakingToken: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>

        extendReward(
            rewardToken: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>

        getRewards(
            stakingToken: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<BigNumber>

        onUpdate(
            token: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            oldStake: PromiseOrValue<BigNumberish>,
            oldSupply: PromiseOrValue<BigNumberish>,
            newStake: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>

        rewardDetails(rewardToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>

        rewardTokens(overrides?: CallOverrides): Promise<BigNumber>

        setAllocPoints(
            rewardToken: PromiseOrValue<string>,
            stakingTokens: PromiseOrValue<string>[],
            allocPoints: PromiseOrValue<BigNumberish>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>

        setReward(
            rewardToken: PromiseOrValue<string>,
            rewards: PromiseOrValue<BigNumberish>,
            start: PromiseOrValue<BigNumberish>,
            duration: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>

        stopReward(
            rewardToken: PromiseOrValue<string>,
            receiver: PromiseOrValue<string>,
            pullTokens: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<BigNumber>
    }

    populateTransaction: {
        allocPointsByReward(
            rewardToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>

        allocPointsByStake(
            stakingToken: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>

        connect(
            stakingToken: PromiseOrValue<string>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>

        extendReward(
            rewardToken: PromiseOrValue<string>,
            amount: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>

        getRewards(
            stakingToken: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            overrides?: CallOverrides
        ): Promise<PopulatedTransaction>

        onUpdate(
            token: PromiseOrValue<string>,
            user: PromiseOrValue<string>,
            oldStake: PromiseOrValue<BigNumberish>,
            oldSupply: PromiseOrValue<BigNumberish>,
            newStake: PromiseOrValue<BigNumberish>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>

        rewardDetails(rewardToken: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>

        rewardTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>

        setAllocPoints(
            rewardToken: PromiseOrValue<string>,
            stakingTokens: PromiseOrValue<string>[],
            allocPoints: PromiseOrValue<BigNumberish>[],
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>

        setReward(
            rewardToken: PromiseOrValue<string>,
            rewards: PromiseOrValue<BigNumberish>,
            start: PromiseOrValue<BigNumberish>,
            duration: PromiseOrValue<BigNumberish>,
            overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>

        stopReward(
            rewardToken: PromiseOrValue<string>,
            receiver: PromiseOrValue<string>,
            pullTokens: PromiseOrValue<boolean>,
            overrides?: Overrides & { from?: PromiseOrValue<string> }
        ): Promise<PopulatedTransaction>
    }
}
