import { writeFileSync } from 'fs'
import { join } from 'path'

interface NativeCurrency {
    symbol: string
    cgId?: string
    cmcId?: number
    decimals: number
    name?: string
}

interface ChainDetails {
    chainKey: string
    chainStatus: string
    nativeChainId: number
    chainStack?: string
    chainLayer?: string
    nativeCurrency: NativeCurrency
    chainType: string
    averageBlockTime?: number
    name?: string
    shortName?: string
}

interface ChainMetadata {
    chainDetails: ChainDetails
    // Other properties we don't need
    [key: string]: any
}

interface LayerZeroApiResponse {
    [chainName: string]: ChainMetadata
}

interface NativeCurrencyConfig {
    [chainName: string]: {
        decimals: number
        symbol: string
    }
}

async function fetchLayerZeroMetadata(): Promise<LayerZeroApiResponse> {
    console.log('Fetching metadata from LayerZero API...')

    const response = await fetch('https://metadata.layerzero-api.com/v1/metadata')

    if (!response.ok) {
        throw new Error(`Failed to fetch metadata: ${response.status} ${response.statusText}`)
    }

    return (await response.json()) as LayerZeroApiResponse
}

function generateNativeCurrencyConfig(metadata: LayerZeroApiResponse): NativeCurrencyConfig {
    console.log('Processing metadata...')

    const config: NativeCurrencyConfig = {}

    for (const [chainName, chainData] of Object.entries(metadata)) {
        try {
            const nativeCurrency = chainData.chainDetails?.nativeCurrency

            if (!nativeCurrency) {
                console.warn(`‚ö†Ô∏è  Skipping ${chainName}: missing nativeCurrency`)
                continue
            }

            if (typeof nativeCurrency.decimals !== 'number' || !nativeCurrency.symbol) {
                console.warn(`‚ö†Ô∏è  Skipping ${chainName}: invalid nativeCurrency data`, nativeCurrency)
                continue
            }

            config[chainName] = {
                decimals: nativeCurrency.decimals,
                symbol: nativeCurrency.symbol,
            }

            console.log(`‚úÖ ${chainName}: ${nativeCurrency.symbol} (${nativeCurrency.decimals} decimals)`)
        } catch (error) {
            console.error(`‚ùå Error processing ${chainName}:`, error)
        }
    }

    return config
}

function writeConfigToFile(config: NativeCurrencyConfig, outputPath: string): void {
    console.log(`Writing configuration to ${outputPath}...`)

    // Add metadata to the output
    const configWithMetadata = {
        _note: 'This file is generated by generateNativeCurrencyConfig.ts - do not edit manually',
        _lastUpdated: new Date().toISOString(),
        _totalChains: Object.keys(config).length,
        ...config,
    }

    const jsonString = JSON.stringify(configWithMetadata, null, 2)
    writeFileSync(outputPath, jsonString, 'utf8')

    console.log(`‚úÖ Successfully wrote ${Object.keys(config).length} chain configurations`)
}

async function main() {
    try {
        console.log('üöÄ Starting native currency configuration generation...\n')

        // Fetch metadata from LayerZero API
        const metadata = await fetchLayerZeroMetadata()
        console.log(`üì• Fetched metadata for ${Object.keys(metadata).length} chains\n`)

        // Generate the native currency configuration
        const config = generateNativeCurrencyConfig(metadata)
        console.log(`\nüìù Generated configuration for ${Object.keys(config).length} chains`)

        // Write to file
        const outputPath = join(__dirname, 'configs', 'nativeCurrencyConfigs.json')
        writeConfigToFile(config, outputPath)

        console.log('\nüéâ Native currency configuration generated successfully!')
        console.log(`üìÅ Output file: ${outputPath}`)
    } catch (error) {
        console.error('‚ùå Error generating native currency configuration:', error)
        process.exit(1)
    }
}

// Run the script if called directly
if (require.main === module) {
    main()
}

export { generateNativeCurrencyConfig, fetchLayerZeroMetadata }
